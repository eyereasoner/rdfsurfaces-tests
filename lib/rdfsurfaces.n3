# -----------------------------------------------------------
# N3 ruleset to interpret and prove RDF Surfaces - Jos De Roo
# -----------------------------------------------------------

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix s: <#>.

# simplify negative surfaces A
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ?B list:select ({ ?Z log:onNegativeSurface ?H } ?K).
    ?H graph:list ?M.
    ?M list:removeDuplicates ?T.
    ?T list:select ({ ?W log:onNegativeSurface ?O } ?N).
    {
        ?O graph:list ?D.
        (?K ?D) list:append ?E.
        ?C graph:list ?E.
    } log:callWithDisjunction {
        ?K list:length ?I.
        ?I math:greaterThan 1.
        ?F graph:list ?N.
        ?Q list:firstRest ({ () log:onNegativeSurface ?F } ?K).
        ?C graph:list ?Q.
    }.
    ?H graph:findBlanks ?R.
    (?Z ?R) list:intersection ?X.
    ?X log:equalTo ().
    ?O graph:findBlanks ?S.
    (?W ?S) list:intersection ?Y.
    (?V ?X ?Y) list:append ?U.
} => {
    ?U log:onNegativeSurface ?C.
}.

# simplify negative surfaces B
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:select ({ () log:onNegativeSurface ?H } ?K).
    ?H graph:list ?J.
    ({ ?J list:member ?M } { ?M log:equalTo { () log:onNegativeSurface ?Y } }) log:forAllIn ?SCOPE.
    ?J list:select ({ () log:onNegativeSurface ?S } ?R).
    ?N graph:list ?K.
    (?S ?N) graph:union ?C.
} => {
    ?V log:onNegativeSurface ?C.
}.

# simplify disjunctive negative surfaces
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?Gl.
    ?Gl list:firstRest ({ ?U log:onNegativeSurface ?H } ?X).
    ({ ?Gl list:member ?M } { ?M log:equalTo { ?U log:onNegativeSurface ?Y } }) log:forAllIn ?SCOPE.
    ?H graph:list ?Hl.
    ?Hl list:member ?Hm.
    ({ ?Gl list:member { ?U log:onNegativeSurface ?J } } { ?J graph:list ?Jl. ?Jl list:member ?Hm }) log:forAllIn ?SCOPE.
} => {
    ?V log:onNegativeSurface { ?U log:onNegativeSurface ?Hm }.
}.

# simplify binary disjunction
{
    s:imp log:equalTo s:imp.
    () log:onNegativeSurface { () log:onNegativeSurface ?G1. () log:onNegativeSurface ?G2 }.
    ?G1 graph:list (?T1).
    ?G2 graph:list (?T2).
    ?T1 log:equalTo { ?S1 ?P ?O }.
    ?T2 log:equalTo { ?S2 ?P ?O }.
} => {
    ?S ?P ?O.
}.

# simplify negative answer surfaces
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ?B list:member { ?X log:onNegativeAnswerSurface ?Y }.
    ?B list:select ({ ?Z log:onNegativeSurface ?H } ?K).
    ?H graph:list ?M.
    ?M list:removeDuplicates ?J.
    ?J list:select (?Q ?T).
    ?R graph:list ?T.
    ?N list:firstRest ({ ?Z log:onNegativeSurface ?R } ?K).
    ?S graph:list ?N.
} => {
    ?V log:onNegativeSurface ?S.
}.

# convert negative surfaces to forward rules A
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ({ ?B s:findComponent (?H ?K) } false true) log:ifThenElseIn ?SCOPE.
    ?B list:notMember { ?I log:onNegativeAnswerSurface ?J }.
    ?B list:select ({ ?U log:onNegativeSurface ?H } ?K).
    ({ ?V log:skolem ?W } { ?U list:member ?W } ?Y) log:collectAllIn ?SCOPE.
    (?K ?Y) list:append ?M.
    ?R graph:list ?M.
    (?V ?U) list:append ?X.
    (?X { ?R => ?H }) graph:negateBlanks ?C.
} => ?C.

# convert negative surfaces to forward rules B
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ({ ?B s:findComponent (?H ?K) } false true) log:ifThenElseIn ?SCOPE.
    ?B list:notMember { ?I log:onNegativeAnswerSurface ?J }.
    (?H { ?B list:select ({ ?U log:onNegativeSurface ?H } ?K) } ?E) log:collectAllIn ?SCOPE.
    (?Q { ?B list:select (?Q ?K). ({ ?Q log:equalTo { ?X log:onNegativeSurface ?Y } } false true) log:ifThenElseIn ?SCOPE } ?F) log:collectAllIn ?SCOPE.
    ?R graph:list ?F.
    (?V { ?R => ?E }) graph:negateBlanks ?C.
} => ?C.

# convert negative surfaces to backward rules
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ?B s:findComponent (?H ?K).
    ?R graph:list ?K.
    (?V { ?H <= ?R }) graph:negateBlanks ?C.
} => ?C.

# convert negative surfaces to universal statements
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?V log:notEqualTo ().
    ?G graph:list (?G).
    ({ ?G log:equalTo { ?Z log:onNegativeSurface ?H } } true { ?Z log:equalTo (). ?H log:equalTo { () log:onNegativeSurface ?G } }) log:ifThenElseIn ?SCOPE.
    ?H graph:findBlanks ?R.
    (?Z ?R) list:intersection ?X.
    ?H graph:member ?M.
    ({ ?V log:skolem ?W } { ?X list:member ?W } ?Y) log:collectAllIn ?SCOPE.
    ?S graph:list ?Y.
    (?V ?X) list:append ?U.
    (?U { ?M <= ?S }) graph:negateBlanks ?C.
} => ?C.

# convert negative surfaces to queries
{
    s:imp log:equalTo s:imp.
    ?V log:onNegativeSurface ?G.
    ?G graph:list ?L.
    ?L list:removeDuplicates ?B.
    ?B list:select ({ ?U log:onNegativeAnswerSurface ?H } ?K).
    ?R graph:list ?K.
    (?V { ?R =^ ?H }) graph:negateBlanks ?C.
} => ?C.

# resolution A (proof by cases)
{
    s:imp log:equalTo s:imp.
    ({ ?X a log:Component } false true) log:ifThenElseIn ?SCOPE.
    ?A => ?B.
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?B list:isList true.
    ?B list:select (?C ?D).
    ?C graph:member ?M.
    ?M => ?E.
    ?M graph:notMember { s:imp log:equalTo s:imp }.
    ?E list:isList false.
    ?G list:firstRest (?E ?D).
} => {
    ?A => ?G.
}.

# resolution B (proof by cases)
{
    s:imp log:equalTo s:imp.
    ({ ?X a log:Component } false true) log:ifThenElseIn ?SCOPE.
    ?A => ?B.
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?B list:isList true.
    ?B list:select (?C ?D).
    ?C graph:member ?M.
    ?M => ().
    ?M graph:notMember { s:imp log:equalTo s:imp }.
} => {
    ?A => ?D.
}.

# resolution C (modus tollens)
{
    s:imp log:equalTo s:imp.
    ({ ?X a log:Component } false true) log:ifThenElseIn ?SCOPE.
    ?A => ?B.
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?B list:isList false.
    {
        ?B => ().
        ?B graph:notMember { s:imp log:equalTo s:imp }.
    } log:callWithDisjunction {
        (?A ?B ) graph:union ?C.
        ?C => ().
    }.
} => {
    ?A => ().
}.

# rewriting A (factoring)
{
    s:imp log:equalTo s:imp.
    ?A => ?B.
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?B list:isList true.
    ?B list:removeDuplicates (?C).
} => {
    ?A => ?C.
}.

# rewriting B (contrapositive)
{
    s:imp log:equalTo s:imp.
    ?A => ?B.
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?B list:isList true.
    ?B list:select (?C ?D).
    ?C graph:member ?M.
    ({ ?M => () } ?A) graph:union ?E.
} => {
    ?E => ?D.
}.

# rewriting C (contrapositive)
{
    s:imp log:equalTo s:imp.
    ?A => ().
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?A graph:list ?B.
    ?B list:select (?C ?M).
    ?C log:isBuiltin false.
    ?E graph:list ?M.
} => {
    ?E => {
        ?C => ().
    }.
}.

# inference fuse
{
    s:imp log:equalTo s:imp.
    ?A => ().
    ?A graph:notMember { s:imp log:equalTo s:imp }.
    ?A log:call true.
} => false.

# support
{
    ?L s:findComponent (?T ?K).
} <= {
    ?L list:select ({ () log:onNegativeSurface ?T } ?K).
    ?T log:equalTo { ?S ?P ?O }.
    ?K list:notMember { ?A log:onNegativeSurface ?B }.
    ?K list:notMember { ?A log:onNegativeAnswerSurface ?B }.
    ?P a log:Component.
}.
