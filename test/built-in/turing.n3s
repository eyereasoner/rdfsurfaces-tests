# ------------------------
# Universal Turing machine
# ------------------------
#
# See https://en.wikipedia.org/wiki/Universal_Turing_machine

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix : <urn:example:>.

# interpreter for Univeral Turing Machine
(_:OutTape _:Machine _:I _:U _:V) log:onNegativeSurface {
    () log:onNegativeSurface {
        () :compute (_:OutTape _:U).
    }.
    _:Machine :start _:I.
    (_:I () "#" ()) :find (_:OutTape _:V).
}.

(_:List _:OutTape _:Head _:Tail _:Machine _:I _:U _:V) log:onNegativeSurface {
    () log:onNegativeSurface {
        _:List :compute (_:OutTape _:U).
    }.
    _:List list:firstRest (_:Head _:Tail).
    _:Machine :start _:I.
    (_:I () _:Head _:Tail) :find (_:OutTape _:V).
}.

(_:State _:Left _:Cell _:Right _:OutTape _:Write _:Move _:Next _:A _:B _:C _:U _:V _:W) log:onNegativeSurface {
    () log:onNegativeSurface {
        (_:State _:Left _:Cell _:Right) :find (_:OutTape _:U).
    }.
    (_:State _:Cell _:Write _:Move) :tape _:Next.
    (_:Move _:Left _:Write _:Right _:A _:B _:C) :move _:V.
    (_:Next _:A _:B _:C) :continue (_:OutTape _:W).
}.

(_:Left _:Cell _:Right _:OutTape _:R _:List _:U _:V) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:halt _:Left _:Cell _:Right) :continue (_:OutTape _:U).
    }.
    _:Left :reverse (_:R _:V).
    _:List list:firstRest (_:Cell _:Right).
    (_:R _:List) list:append _:OutTape.
}.

(_:State _:Left _:Cell _:Right _:OutTape _:U _:V) log:onNegativeSurface {
    () log:onNegativeSurface {
        (_:State _:Left _:Cell _:Right) :continue (_:OutTape _:U).
    }.
    (_:State _:Left _:Cell _:Right) :find (_:OutTape _:V).
}.

(_:Cell _:Right _:L _:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:left () _:Cell _:Right () "#" _:L) :move _:U.
    }.
    _:L list:firstRest (_:Cell _:Right).
}.

(_:List _:Cell _:Right _:Tail _:Head _:L _:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:left _:List _:Cell _:Right _:Tail _:Head _:L) :move _:U.
    }.
    _:List list:firstRest (_:Head _:Tail).
    _:L list:firstRest (_:Cell _:Right).
}.

(_:Left _:Cell _:Right _:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:stop _:Left _:Cell _:Right _:Left _:Cell _:Right) :move _:U.
    }.
}.

(_:Left _:Cell _:L _:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:right _:Left _:Cell () _:L "#" ()) :move _:U.
    }.
    _:L list:firstRest (_:Cell _:Left).
}.

(_:Left _:Cell _:List _:L _:Head _:Tail _:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        (:right _:Left _:Cell _:List _:L _:Head _:Tail) :move _:U.
    }.
    _:List list:firstRest (_:Head _:Tail).
    _:L list:firstRest (_:Cell _:Left).
}.

(_:U) log:onNegativeSurface {
    () log:onNegativeSurface {
        () :reverse (() _:U).
    }.
}.

(_:List _:Reverse _:Head _:Tail _:R _:U _:V) log:onNegativeSurface {
    () log:onNegativeSurface {
        _:List :reverse (_:Reverse _:U).
    }.
    _:List list:firstRest (_:Head _:Tail).
    _:Tail :reverse (_:R _:V).
    (_:R (_:Head)) list:append _:Reverse.
}.

# a Turing machine to add 1 to a binary number
:add1 :start 0.

(0 0 0 :right) :tape 0.
(0 1 1 :right) :tape 0.
(0 "#" "#" :left) :tape 1.
(1 0 1 :stop) :tape :halt.
(1 1 0 :left) :tape 1.
(1 "#" 1 :stop) :tape :halt.

# query
() log:onNegativeSurface {
    (1 0 1 0 0 1) :compute ((1 0 1 0 1 0 "#") :exact).
    (1 0 1 1 1 1) :compute ((1 1 0 0 0 0 "#") :exact).
    (1 1 1 1 1 1) :compute ((1 0 0 0 0 0 0 "#") :exact).
    () :compute ((1 "#") :exact).
    () log:onNegativeAnswerSurface {
        :test :is true.
    }.
}.
